<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" dir="ltr" lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>PostgreSQL: Documentation: devel: Message Flow</title>
    <style type="text/css" media="screen" title="Normal Text">@import url("/dyncss/docs.css?35336e31");</style>
    <script src="PostgreSQL%20%20Documentation%20%20devel%20%20Message%20Flow_pliki/ga.js" async="" type="text/javascript"></script><script type="text/javascript" src="PostgreSQL%20%20Documentation%20%20devel%20%20Message%20Flow_pliki/monospacefix.js"></script></head><body><pre id="monotest" style="display: none;">&nbsp;</pre><p id="paratest" style="display: none;">&nbsp;</p><style type="text/css" media="screen">#docContainer tt, #docContainer pre, #docContainer code{font-size: 1.3em;}</style>

    <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-1345454-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


<div id="docHeader">
	<div id="docHeaderLogo">
		<a href="http://www.postgresql.org/" title="PostgreSQL"><img src="PostgreSQL%20%20Documentation%20%20devel%20%20Message%20Flow_pliki/hdr_logo.png" alt="PostgreSQL" height="80" width="206"></a>
	</div>
</div>

<div id="docContainerWrap">
<div id="docContainer">
<div id="docNavSearchContainer">
<div id="docSearch">
	<form action="/search/" method="get">
	<div>
	<input name="u" value="/docs/devel/" type="hidden">
	<label for="q">Search Documentation:&nbsp;</label><input id="q" name="q" size="20" onfocus="if( this.value==this.defaultValue ) this.value='';" value="Search" type="text"><input id="submit" value="Search" type="submit">
	</div>
	</form>
</div>
<div id="docNav">
<a href="http://www.postgresql.org/" title="Home">Home</a> → <a href="http://www.postgresql.org/docs" title="Documentation">Documentation</a> → <a href="http://www.postgresql.org/docs/manuals" title="Manuals">Manuals</a> → <a href="http://www.postgresql.org/docs/devel/static/index.html">PostgreSQL devel</a> (2014-07-29 12:36:25)
</div>
<div id="docVersions">
This page in other versions:


	
	
	<a href="http://www.postgresql.org/docs/9.0/static/protocol-flow.html" title="This page in version 9.0">9.0</a>
	

	/
	
	<a href="http://www.postgresql.org/docs/9.1/static/protocol-flow.html" title="This page in version 9.1">9.1</a>
	

	/
	
	<a href="http://www.postgresql.org/docs/9.2/static/protocol-flow.html" title="This page in version 9.2">9.2</a>
	

	/
	
	<a href="http://www.postgresql.org/docs/9.3/static/protocol-flow.html" title="This page in version 9.3">9.3</a>
	




&nbsp;|&nbsp; Development versions:

	
	
	<b>devel</b>
	

	/
	
	<a href="http://www.postgresql.org/docs/9.4/static/protocol-flow.html" title="This page in version 9.4" rel="nofollow">9.4</a>
	




&nbsp;|&nbsp; Unsupported versions:

	
	
	<a href="http://www.postgresql.org/docs/7.4/static/protocol-flow.html" title="This page in version 7.4" rel="nofollow">7.4</a>
	

	/
	
	<a href="http://www.postgresql.org/docs/8.0/static/protocol-flow.html" title="This page in version 8.0" rel="nofollow">8.0</a>
	

	/
	
	<a href="http://www.postgresql.org/docs/8.1/static/protocol-flow.html" title="This page in version 8.1" rel="nofollow">8.1</a>
	

	/
	
	<a href="http://www.postgresql.org/docs/8.2/static/protocol-flow.html" title="This page in version 8.2" rel="nofollow">8.2</a>
	

	/
	
	<a href="http://www.postgresql.org/docs/8.3/static/protocol-flow.html" title="This page in version 8.3" rel="nofollow">8.3</a>
	

	/
	
	<a href="http://www.postgresql.org/docs/8.4/static/protocol-flow.html" title="This page in version 8.4" rel="nofollow">8.4</a>
	


</div>
</div>

<div id="docContent">
<div class="NAVHEADER">
  <table summary="Header navigation table" cellpadding="0" cellspacing="0" border="0" width="100%">
    <tbody><tr>
      <th colspan="4" align="center" valign="bottom"><a href="http://www.postgresql.org/docs/devel/static/index.html">PostgreSQL 9.5devel Documentation</a></th>
    </tr>

    <tr>
      <td align="left" valign="top" width="10%"><a title="Overview" href="http://www.postgresql.org/docs/devel/static/protocol-overview.html" accesskey="P">Prev</a></td>

      <td align="left" valign="top" width="10%"><a href="http://www.postgresql.org/docs/devel/static/protocol.html" accesskey="U">Up</a></td>

      <td align="center" valign="bottom" width="60%">Chapter 49.
      Frontend/Backend Protocol</td>

      <td align="right" valign="top" width="20%"><a title="Streaming Replication Protocol" href="http://www.postgresql.org/docs/devel/static/protocol-replication.html" accesskey="N">Next</a></td>
    </tr>
  </tbody></table>
  <hr class="c1" width="100%">
</div>

<div class="SECT1">
  <h1 class="SECT1"><a name="PROTOCOL-FLOW" id="PROTOCOL-FLOW">49.2. Message Flow</a></h1>

  <p>This section describes the message flow and the semantics of
  each message type. (Details of the exact representation of each
  message appear in <a href="http://www.postgresql.org/docs/devel/static/protocol-message-formats.html">Section
  49.5</a>.) There are several different sub-protocols depending on
  the state of the connection: start-up, query, function call,
  <tt class="COMMAND">COPY</tt>, and termination. There are also
  special provisions for asynchronous operations (including
  notification responses and command cancellation), which can occur
  at any time after the start-up phase.</p>

  <div class="SECT2">
    <h2 class="SECT2"><a name="AEN102555" id="AEN102555">49.2.1.
    Start-up</a></h2>

    <p>To begin a session, a frontend opens a connection to the
    server and sends a startup message. This message includes the
    names of the user and of the database the user wants to connect
    to; it also identifies the particular protocol version to be
    used. (Optionally, the startup message can include additional
    settings for run-time parameters.) The server then uses this
    information and the contents of its configuration files (such
    as <tt class="FILENAME">pg_hba.conf</tt>) to determine whether
    the connection is provisionally acceptable, and what additional
    authentication is required (if any).</p>

    <p>The server then sends an appropriate authentication request
    message, to which the frontend must reply with an appropriate
    authentication response message (such as a password). For all
    authentication methods except GSSAPI and SSPI, there is at most
    one request and one response. In some methods, no response at
    all is needed from the frontend, and so no authentication
    request occurs. For GSSAPI and SSPI, multiple exchanges of
    packets may be needed to complete the authentication.</p>

    <p>The authentication cycle ends with the server either
    rejecting the connection attempt (ErrorResponse), or sending
    AuthenticationOk.</p>

    <p>The possible messages from the server in this phase are:</p>

    <div class="VARIABLELIST">
      <dl>
        <dt>ErrorResponse</dt>

        <dd>
          <p>The connection attempt has been rejected. The server
          then immediately closes the connection.</p>
        </dd>

        <dt>AuthenticationOk</dt>

        <dd>
          <p>The authentication exchange is successfully
          completed.</p>
        </dd>

        <dt>AuthenticationKerberosV5</dt>

        <dd>
          <p>The frontend must now take part in a Kerberos V5
          authentication dialog (not described here, part of the
          Kerberos specification) with the server. If this is
          successful, the server responds with an AuthenticationOk,
          otherwise it responds with an ErrorResponse. This is no
          longer supported. This is not supported any more.</p>
        </dd>

        <dt>AuthenticationCleartextPassword</dt>

        <dd>
          <p>The frontend must now send a PasswordMessage
          containing the password in clear-text form. If this is
          the correct password, the server responds with an
          AuthenticationOk, otherwise it responds with an
          ErrorResponse.</p>
        </dd>

        <dt>AuthenticationMD5Password</dt>

        <dd>
          <p>The frontend must now send a PasswordMessage
          containing the password (with username) encrypted via
          MD5, then encrypted again using the 4-byte random salt
          specified in the AuthenticationMD5Password message. If
          this is the correct password, the server responds with an
          AuthenticationOk, otherwise it responds with an
          ErrorResponse. The actual PasswordMessage can be computed
          in SQL as <tt class="LITERAL">concat('md5',
          md5(concat(md5(concat(password, username)),
          random-salt)))</tt>. (Keep in mind the <code class="FUNCTION">md5()</code> function returns its result as a
          hex string.)</p>
        </dd>

        <dt>AuthenticationSCMCredential</dt>

        <dd>
          <p>This response is only possible for local Unix-domain
          connections on platforms that support SCM credential
          messages. The frontend must issue an SCM credential
          message and then send a single data byte. (The contents
          of the data byte are uninteresting; it's only used to
          ensure that the server waits long enough to receive the
          credential message.) If the credential is acceptable, the
          server responds with an AuthenticationOk, otherwise it
          responds with an ErrorResponse. (This message type is
          only issued by pre-9.1 servers. It may eventually be
          removed from the protocol specification.)</p>
        </dd>

        <dt>AuthenticationGSS</dt>

        <dd>
          <p>The frontend must now initiate a GSSAPI negotiation.
          The frontend will send a PasswordMessage with the first
          part of the GSSAPI data stream in response to this. If
          further messages are needed, the server will respond with
          AuthenticationGSSContinue.</p>
        </dd>

        <dt>AuthenticationSSPI</dt>

        <dd>
          <p>The frontend must now initiate a SSPI negotiation. The
          frontend will send a PasswordMessage with the first part
          of the SSPI data stream in response to this. If further
          messages are needed, the server will respond with
          AuthenticationGSSContinue.</p>
        </dd>

        <dt>AuthenticationGSSContinue</dt>

        <dd>
          <p>This message contains the response data from the
          previous step of GSSAPI or SSPI negotiation
          (AuthenticationGSS, AuthenticationSSPI or a previous
          AuthenticationGSSContinue). If the GSSAPI or SSPI data in
          this message indicates more data is needed to complete
          the authentication, the frontend must send that data as
          another PasswordMessage. If GSSAPI or SSPI authentication
          is completed by this message, the server will next send
          AuthenticationOk to indicate successful authentication or
          ErrorResponse to indicate failure.</p>
        </dd>
      </dl>
    </div>

    <p>If the frontend does not support the authentication method
    requested by the server, then it should immediately close the
    connection.</p>

    <p>After having received AuthenticationOk, the frontend must
    wait for further messages from the server. In this phase a
    backend process is being started, and the frontend is just an
    interested bystander. It is still possible for the startup
    attempt to fail (ErrorResponse), but in the normal case the
    backend will send some ParameterStatus messages,
    BackendKeyData, and finally ReadyForQuery.</p>

    <p>During this phase the backend will attempt to apply any
    additional run-time parameter settings that were given in the
    startup message. If successful, these values become session
    defaults. An error causes ErrorResponse and exit.</p>

    <p>The possible messages from the backend in this phase
    are:</p>

    <div class="VARIABLELIST">
      <dl>
        <dt>BackendKeyData</dt>

        <dd>
          <p>This message provides secret-key data that the
          frontend must save if it wants to be able to issue cancel
          requests later. The frontend should not respond to this
          message, but should continue listening for a
          ReadyForQuery message.</p>
        </dd>

        <dt>ParameterStatus</dt>

        <dd>
          <p>This message informs the frontend about the current
          (initial) setting of backend parameters, such as <a href="http://www.postgresql.org/docs/devel/static/runtime-config-client.html#GUC-CLIENT-ENCODING">client_encoding</a>
          or <a href="http://www.postgresql.org/docs/devel/static/runtime-config-client.html#GUC-DATESTYLE">DateStyle</a>.
          The frontend can ignore this message, or record the
          settings for its future use; see <a href="http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-ASYNC">Section 49.2.6</a>
          for more details. The frontend should not respond to this
          message, but should continue listening for a
          ReadyForQuery message.</p>
        </dd>

        <dt>ReadyForQuery</dt>

        <dd>
          <p>Start-up is completed. The frontend can now issue
          commands.</p>
        </dd>

        <dt>ErrorResponse</dt>

        <dd>
          <p>Start-up failed. The connection is closed after
          sending this message.</p>
        </dd>

        <dt>NoticeResponse</dt>

        <dd>
          <p>A warning message has been issued. The frontend should
          display the message but continue listening for
          ReadyForQuery or ErrorResponse.</p>
        </dd>
      </dl>
    </div>

    <p>The ReadyForQuery message is the same one that the backend
    will issue after each command cycle. Depending on the coding
    needs of the frontend, it is reasonable to consider
    ReadyForQuery as starting a command cycle, or to consider
    ReadyForQuery as ending the start-up phase and each subsequent
    command cycle.</p>
  </div>

  <div class="SECT2">
    <h2 class="SECT2"><a name="AEN102630" id="AEN102630">49.2.2.
    Simple Query</a></h2>

    <p>A simple query cycle is initiated by the frontend sending a
    Query message to the backend. The message includes an SQL
    command (or commands) expressed as a text string. The backend
    then sends one or more response messages depending on the
    contents of the query command string, and finally a
    ReadyForQuery response message. ReadyForQuery informs the
    frontend that it can safely send a new command. (It is not
    actually necessary for the frontend to wait for ReadyForQuery
    before issuing another command, but the frontend must then take
    responsibility for figuring out what happens if the earlier
    command fails and already-issued later commands succeed.)</p>

    <p>The possible response messages from the backend are:</p>

    <div class="VARIABLELIST">
      <dl>
        <dt>CommandComplete</dt>

        <dd>
          <p>An SQL command completed normally.</p>
        </dd>

        <dt>CopyInResponse</dt>

        <dd>
          <p>The backend is ready to copy data from the frontend to
          a table; see <a href="http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-COPY">Section
          49.2.5</a>.</p>
        </dd>

        <dt>CopyOutResponse</dt>

        <dd>
          <p>The backend is ready to copy data from a table to the
          frontend; see <a href="http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-COPY">Section
          49.2.5</a>.</p>
        </dd>

        <dt>RowDescription</dt>

        <dd>
          <p>Indicates that rows are about to be returned in
          response to a <tt class="COMMAND">SELECT</tt>, <tt class="COMMAND">FETCH</tt>, etc query. The contents of this
          message describe the column layout of the rows. This will
          be followed by a DataRow message for each row being
          returned to the frontend.</p>
        </dd>

        <dt>DataRow</dt>

        <dd>
          <p>One of the set of rows returned by a <tt class="COMMAND">SELECT</tt>, <tt class="COMMAND">FETCH</tt>,
          etc query.</p>
        </dd>

        <dt>EmptyQueryResponse</dt>

        <dd>
          <p>An empty query string was recognized.</p>
        </dd>

        <dt>ErrorResponse</dt>

        <dd>
          <p>An error has occurred.</p>
        </dd>

        <dt>ReadyForQuery</dt>

        <dd>
          <p>Processing of the query string is complete. A separate
          message is sent to indicate this because the query string
          might contain multiple SQL commands. (CommandComplete
          marks the end of processing one SQL command, not the
          whole string.) ReadyForQuery will always be sent, whether
          processing terminates successfully or with an error.</p>
        </dd>

        <dt>NoticeResponse</dt>

        <dd>
          <p>A warning message has been issued in relation to the
          query. Notices are in addition to other responses, i.e.,
          the backend will continue processing the command.</p>
        </dd>
      </dl>
    </div>

    <p>The response to a <tt class="COMMAND">SELECT</tt> query (or
    other queries that return row sets, such as <tt class="COMMAND">EXPLAIN</tt> or <tt class="COMMAND">SHOW</tt>)
    normally consists of RowDescription, zero or more DataRow
    messages, and then CommandComplete. <tt class="COMMAND">COPY</tt> to or from the frontend invokes special
    protocol as described in <a href="http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-COPY">Section 49.2.5</a>. All
    other query types normally produce only a CommandComplete
    message.</p>

    <p>Since a query string could contain several queries
    (separated by semicolons), there might be several such response
    sequences before the backend finishes processing the query
    string. ReadyForQuery is issued when the entire string has been
    processed and the backend is ready to accept a new query
    string.</p>

    <p>If a completely empty (no contents other than whitespace)
    query string is received, the response is EmptyQueryResponse
    followed by ReadyForQuery.</p>

    <p>In the event of an error, ErrorResponse is issued followed
    by ReadyForQuery. All further processing of the query string is
    aborted by ErrorResponse (even if more queries remained in it).
    Note that this might occur partway through the sequence of
    messages generated by an individual query.</p>

    <p>In simple Query mode, the format of retrieved values is
    always text, except when the given command is a <tt class="COMMAND">FETCH</tt> from a cursor declared with the <tt class="LITERAL">BINARY</tt> option. In that case, the retrieved
    values are in binary format. The format codes given in the
    RowDescription message tell which format is being used.</p>

    <p>A frontend must be prepared to accept ErrorResponse and
    NoticeResponse messages whenever it is expecting any other type
    of message. See also <a href="http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-ASYNC">Section 49.2.6</a>
    concerning messages that the backend might generate due to
    outside events.</p>

    <p>Recommended practice is to code frontends in a state-machine
    style that will accept any message type at any time that it
    could make sense, rather than wiring in assumptions about the
    exact sequence of messages.</p>
  </div>

  <div class="SECT2">
    <h2 class="SECT2"><a name="PROTOCOL-FLOW-EXT-QUERY" id="PROTOCOL-FLOW-EXT-QUERY">49.2.3. Extended Query</a></h2>

    <p>The extended query protocol breaks down the above-described
    simple query protocol into multiple steps. The results of
    preparatory steps can be re-used multiple times for improved
    efficiency. Furthermore, additional features are available,
    such as the possibility of supplying data values as separate
    parameters instead of having to insert them directly into a
    query string.</p>

    <p>In the extended protocol, the frontend first sends a Parse
    message, which contains a textual query string, optionally some
    information about data types of parameter placeholders, and the
    name of a destination prepared-statement object (an empty
    string selects the unnamed prepared statement). The response is
    either ParseComplete or ErrorResponse. Parameter data types can
    be specified by OID; if not given, the parser attempts to infer
    the data types in the same way as it would do for untyped
    literal string constants.</p>

    <div class="NOTE">
      <blockquote class="NOTE">
        <p><b>Note:</b> A parameter data type can be left
        unspecified by setting it to zero, or by making the array
        of parameter type OIDs shorter than the number of parameter
        symbols (<tt class="LITERAL">$</tt><tt class="REPLACEABLE c2">n</tt>) used in the query string. Another
        special case is that a parameter's type can be specified as
        <tt class="TYPE">void</tt> (that is, the OID of the
        <tt class="TYPE">void</tt> pseudotype). This is meant to
        allow parameter symbols to be used for function parameters
        that are actually OUT parameters. Ordinarily there is no
        context in which a <tt class="TYPE">void</tt> parameter
        could be used, but if such a parameter symbol appears in a
        function's parameter list, it is effectively ignored. For
        example, a function call such as <tt class="LITERAL">foo($1,$2,$3,$4)</tt> could match a function with
        two IN and two OUT arguments, if <tt class="LITERAL">$3</tt> and <tt class="LITERAL">$4</tt> are
        specified as having type <tt class="TYPE">void</tt>.</p>
      </blockquote>
    </div>

    <div class="NOTE">
      <blockquote class="NOTE">
        <p><b>Note:</b> The query string contained in a Parse
        message cannot include more than one SQL statement; else a
        syntax error is reported. This restriction does not exist
        in the simple-query protocol, but it does exist in the
        extended protocol, because allowing prepared statements or
        portals to contain multiple commands would complicate the
        protocol unduly.</p>
      </blockquote>
    </div>

    <p>If successfully created, a named prepared-statement object
    lasts till the end of the current session, unless explicitly
    destroyed. An unnamed prepared statement lasts only until the
    next Parse statement specifying the unnamed statement as
    destination is issued. (Note that a simple Query message also
    destroys the unnamed statement.) Named prepared statements must
    be explicitly closed before they can be redefined by another
    Parse message, but this is not required for the unnamed
    statement. Named prepared statements can also be created and
    accessed at the SQL command level, using <tt class="COMMAND">PREPARE</tt> and <tt class="COMMAND">EXECUTE</tt>.</p>

    <p>Once a prepared statement exists, it can be readied for
    execution using a Bind message. The Bind message gives the name
    of the source prepared statement (empty string denotes the
    unnamed prepared statement), the name of the destination portal
    (empty string denotes the unnamed portal), and the values to
    use for any parameter placeholders present in the prepared
    statement. The supplied parameter set must match those needed
    by the prepared statement. (If you declared any <tt class="TYPE">void</tt> parameters in the Parse message, pass NULL
    values for them in the Bind message.) Bind also specifies the
    format to use for any data returned by the query; the format
    can be specified overall, or per-column. The response is either
    BindComplete or ErrorResponse.</p>

    <div class="NOTE">
      <blockquote class="NOTE">
        <p><b>Note:</b> The choice between text and binary output
        is determined by the format codes given in Bind, regardless
        of the SQL command involved. The <tt class="LITERAL">BINARY</tt> attribute in cursor declarations is
        irrelevant when using extended query protocol.</p>
      </blockquote>
    </div>

    <p>Query planning typically occurs when the Bind message is
    processed. If the prepared statement has no parameters, or is
    executed repeatedly, the server might save the created plan and
    re-use it during subsequent Bind messages for the same prepared
    statement. However, it will do so only if it finds that a
    generic plan can be created that is not much less efficient
    than a plan that depends on the specific parameter values
    supplied. This happens transparently so far as the protocol is
    concerned.</p>

    <p>If successfully created, a named portal object lasts till
    the end of the current transaction, unless explicitly
    destroyed. An unnamed portal is destroyed at the end of the
    transaction, or as soon as the next Bind statement specifying
    the unnamed portal as destination is issued. (Note that a
    simple Query message also destroys the unnamed portal.) Named
    portals must be explicitly closed before they can be redefined
    by another Bind message, but this is not required for the
    unnamed portal. Named portals can also be created and accessed
    at the SQL command level, using <tt class="COMMAND">DECLARE
    CURSOR</tt> and <tt class="COMMAND">FETCH</tt>.</p>

    <p>Once a portal exists, it can be executed using an Execute
    message. The Execute message specifies the portal name (empty
    string denotes the unnamed portal) and a maximum result-row
    count (zero meaning <span class="QUOTE">"fetch all
    rows"</span>). The result-row count is only meaningful for
    portals containing commands that return row sets; in other
    cases the command is always executed to completion, and the row
    count is ignored. The possible responses to Execute are the
    same as those described above for queries issued via simple
    query protocol, except that Execute doesn't cause ReadyForQuery
    or RowDescription to be issued.</p>

    <p>If Execute terminates before completing the execution of a
    portal (due to reaching a nonzero result-row count), it will
    send a PortalSuspended message; the appearance of this message
    tells the frontend that another Execute should be issued
    against the same portal to complete the operation. The
    CommandComplete message indicating completion of the source SQL
    command is not sent until the portal's execution is completed.
    Therefore, an Execute phase is always terminated by the
    appearance of exactly one of these messages: CommandComplete,
    EmptyQueryResponse (if the portal was created from an empty
    query string), ErrorResponse, or PortalSuspended.</p>

    <p>At completion of each series of extended-query messages, the
    frontend should issue a Sync message. This parameterless
    message causes the backend to close the current transaction if
    it's not inside a <tt class="COMMAND">BEGIN</tt>/<tt class="COMMAND">COMMIT</tt> transaction block (<span class="QUOTE">"close"</span> meaning to commit if no error, or roll
    back if error). Then a ReadyForQuery response is issued. The
    purpose of Sync is to provide a resynchronization point for
    error recovery. When an error is detected while processing any
    extended-query message, the backend issues ErrorResponse, then
    reads and discards messages until a Sync is reached, then
    issues ReadyForQuery and returns to normal message processing.
    (But note that no skipping occurs if an error is detected
    <span class="emphasis EMPHASIS c3">while</span> processing Sync
    — this ensures that there is one and only one ReadyForQuery
    sent for each Sync.)</p>

    <div class="NOTE">
      <blockquote class="NOTE">
        <p><b>Note:</b> Sync does not cause a transaction block
        opened with <tt class="COMMAND">BEGIN</tt> to be closed. It
        is possible to detect this situation since the
        ReadyForQuery message includes transaction status
        information.</p>
      </blockquote>
    </div>

    <p>In addition to these fundamental, required operations, there
    are several optional operations that can be used with
    extended-query protocol.</p>

    <p>The Describe message (portal variant) specifies the name of
    an existing portal (or an empty string for the unnamed portal).
    The response is a RowDescription message describing the rows
    that will be returned by executing the portal; or a NoData
    message if the portal does not contain a query that will return
    rows; or ErrorResponse if there is no such portal.</p>

    <p>The Describe message (statement variant) specifies the name
    of an existing prepared statement (or an empty string for the
    unnamed prepared statement). The response is a
    ParameterDescription message describing the parameters needed
    by the statement, followed by a RowDescription message
    describing the rows that will be returned when the statement is
    eventually executed (or a NoData message if the statement will
    not return rows). ErrorResponse is issued if there is no such
    prepared statement. Note that since Bind has not yet been
    issued, the formats to be used for returned columns are not yet
    known to the backend; the format code fields in the
    RowDescription message will be zeroes in this case.</p>

    <div class="TIP">
      <blockquote class="TIP">
        <p><b>Tip:</b> In most scenarios the frontend should issue
        one or the other variant of Describe before issuing
        Execute, to ensure that it knows how to interpret the
        results it will get back.</p>
      </blockquote>
    </div>

    <p>The Close message closes an existing prepared statement or
    portal and releases resources. It is not an error to issue
    Close against a nonexistent statement or portal name. The
    response is normally CloseComplete, but could be ErrorResponse
    if some difficulty is encountered while releasing resources.
    Note that closing a prepared statement implicitly closes any
    open portals that were constructed from that statement.</p>

    <p>The Flush message does not cause any specific output to be
    generated, but forces the backend to deliver any data pending
    in its output buffers. A Flush must be sent after any
    extended-query command except Sync, if the frontend wishes to
    examine the results of that command before issuing more
    commands. Without Flush, messages returned by the backend will
    be combined into the minimum possible number of packets to
    minimize network overhead.</p>

    <div class="NOTE">
      <blockquote class="NOTE">
        <p><b>Note:</b> The simple Query message is approximately
        equivalent to the series Parse, Bind, portal Describe,
        Execute, Close, Sync, using the unnamed prepared statement
        and portal objects and no parameters. One difference is
        that it will accept multiple SQL statements in the query
        string, automatically performing the bind/describe/execute
        sequence for each one in succession. Another difference is
        that it will not return ParseComplete, BindComplete,
        CloseComplete, or NoData messages.</p>
      </blockquote>
    </div>
  </div>

  <div class="SECT2">
    <h2 class="SECT2"><a name="AEN102741" id="AEN102741">49.2.4.
    Function Call</a></h2>

    <p>The Function Call sub-protocol allows the client to request
    a direct call of any function that exists in the database's
    <tt class="STRUCTNAME">pg_proc</tt> system catalog. The client
    must have execute permission for the function.</p>

    <div class="NOTE">
      <blockquote class="NOTE">
        <p><b>Note:</b> The Function Call sub-protocol is a legacy
        feature that is probably best avoided in new code. Similar
        results can be accomplished by setting up a prepared
        statement that does <tt class="LITERAL">SELECT function($1,
        ...)</tt>. The Function Call cycle can then be replaced
        with Bind/Execute.</p>
      </blockquote>
    </div>

    <p>A Function Call cycle is initiated by the frontend sending a
    FunctionCall message to the backend. The backend then sends one
    or more response messages depending on the results of the
    function call, and finally a ReadyForQuery response message.
    ReadyForQuery informs the frontend that it can safely send a
    new query or function call.</p>

    <p>The possible response messages from the backend are:</p>

    <div class="VARIABLELIST">
      <dl>
        <dt>ErrorResponse</dt>

        <dd>
          <p>An error has occurred.</p>
        </dd>

        <dt>FunctionCallResponse</dt>

        <dd>
          <p>The function call was completed and returned the
          result given in the message. (Note that the Function Call
          protocol can only handle a single scalar result, not a
          row type or set of results.)</p>
        </dd>

        <dt>ReadyForQuery</dt>

        <dd>
          <p>Processing of the function call is complete.
          ReadyForQuery will always be sent, whether processing
          terminates successfully or with an error.</p>
        </dd>

        <dt>NoticeResponse</dt>

        <dd>
          <p>A warning message has been issued in relation to the
          function call. Notices are in addition to other
          responses, i.e., the backend will continue processing the
          command.</p>
        </dd>
      </dl>
    </div>
  </div>

  <div class="SECT2">
    <h2 class="SECT2"><a name="PROTOCOL-COPY" id="PROTOCOL-COPY">49.2.5. COPY Operations</a></h2>

    <p>The <tt class="COMMAND">COPY</tt> command allows high-speed
    bulk data transfer to or from the server. Copy-in and copy-out
    operations each switch the connection into a distinct
    sub-protocol, which lasts until the operation is completed.</p>

    <p>Copy-in mode (data transfer to the server) is initiated when
    the backend executes a <tt class="COMMAND">COPY FROM STDIN</tt>
    SQL statement. The backend sends a CopyInResponse message to
    the frontend. The frontend should then send zero or more
    CopyData messages, forming a stream of input data. (The message
    boundaries are not required to have anything to do with row
    boundaries, although that is often a reasonable choice.) The
    frontend can terminate the copy-in mode by sending either a
    CopyDone message (allowing successful termination) or a
    CopyFail message (which will cause the <tt class="COMMAND">COPY</tt> SQL statement to fail with an error). The
    backend then reverts to the command-processing mode it was in
    before the <tt class="COMMAND">COPY</tt> started, which will be
    either simple or extended query protocol. It will next send
    either CommandComplete (if successful) or ErrorResponse (if
    not).</p>

    <p>In the event of a backend-detected error during copy-in mode
    (including receipt of a CopyFail message), the backend will
    issue an ErrorResponse message. If the <tt class="COMMAND">COPY</tt> command was issued via an extended-query
    message, the backend will now discard frontend messages until a
    Sync message is received, then it will issue ReadyForQuery and
    return to normal processing. If the <tt class="COMMAND">COPY</tt> command was issued in a simple Query
    message, the rest of that message is discarded and
    ReadyForQuery is issued. In either case, any subsequent
    CopyData, CopyDone, or CopyFail messages issued by the frontend
    will simply be dropped.</p>

    <p>The backend will ignore Flush and Sync messages received
    during copy-in mode. Receipt of any other non-copy message type
    constitutes an error that will abort the copy-in state as
    described above. (The exception for Flush and Sync is for the
    convenience of client libraries that always send Flush or Sync
    after an Execute message, without checking whether the command
    to be executed is a <tt class="COMMAND">COPY FROM
    STDIN</tt>.)</p>

    <p>Copy-out mode (data transfer from the server) is initiated
    when the backend executes a <tt class="COMMAND">COPY TO
    STDOUT</tt> SQL statement. The backend sends a CopyOutResponse
    message to the frontend, followed by zero or more CopyData
    messages (always one per row), followed by CopyDone. The
    backend then reverts to the command-processing mode it was in
    before the <tt class="COMMAND">COPY</tt> started, and sends
    CommandComplete. The frontend cannot abort the transfer (except
    by closing the connection or issuing a Cancel request), but it
    can discard unwanted CopyData and CopyDone messages.</p>

    <p>In the event of a backend-detected error during copy-out
    mode, the backend will issue an ErrorResponse message and
    revert to normal processing. The frontend should treat receipt
    of ErrorResponse as terminating the copy-out mode.</p>

    <p>It is possible for NoticeResponse and ParameterStatus
    messages to be interspersed between CopyData messages;
    frontends must handle these cases, and should be prepared for
    other asynchronous message types as well (see <a href="http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-ASYNC">Section 49.2.6</a>).
    Otherwise, any message type other than CopyData or CopyDone may
    be treated as terminating copy-out mode.</p>

    <p>There is another Copy-related mode called copy-both, which
    allows high-speed bulk data transfer to <span class="emphasis EMPHASIS c3">and</span> from the server. Copy-both
    mode is initiated when a backend in walsender mode executes a
    <tt class="COMMAND">START_REPLICATION</tt> statement. The
    backend sends a CopyBothResponse message to the frontend. Both
    the backend and the frontend may then send CopyData messages
    until either end sends a CopyDone message. After the client
    sends a CopyDone message, the connection goes from copy-both
    mode to copy-out mode, and the client may not send any more
    CopyData messages. Similarly, when the server sends a CopyDone
    message, the connection goes into copy-in mode, and the server
    may not send any more CopyData messages. After both sides have
    sent a CopyDone message, the copy mode is terminated, and the
    backend reverts to the command-processing mode. In the event of
    a backend-detected error during copy-both mode, the backend
    will issue an ErrorResponse message, discard frontend messages
    until a Sync message is received, and then issue ReadyForQuery
    and return to normal processing. The frontend should treat
    receipt of ErrorResponse as terminating the copy in both
    directions; no CopyDone should be sent in this case. See
    <a href="http://www.postgresql.org/docs/devel/static/protocol-replication.html">Section 49.3</a> for more
    information on the subprotocol transmitted over copy-both
    mode.</p>

    <p>The CopyInResponse, CopyOutResponse and CopyBothResponse
    messages include fields that inform the frontend of the number
    of columns per row and the format codes being used for each
    column. (As of the present implementation, all columns in a
    given <tt class="COMMAND">COPY</tt> operation will use the same
    format, but the message design does not assume this.)</p>
  </div>

  <div class="SECT2">
    <h2 class="SECT2"><a name="PROTOCOL-ASYNC" id="PROTOCOL-ASYNC">49.2.6. Asynchronous Operations</a></h2>

    <p>There are several cases in which the backend will send
    messages that are not specifically prompted by the frontend's
    command stream. Frontends must be prepared to deal with these
    messages at any time, even when not engaged in a query. At
    minimum, one should check for these cases before beginning to
    read a query response.</p>

    <p>It is possible for NoticeResponse messages to be generated
    due to outside activity; for example, if the database
    administrator commands a <span class="QUOTE">"fast"</span>
    database shutdown, the backend will send a NoticeResponse
    indicating this fact before closing the connection.
    Accordingly, frontends should always be prepared to accept and
    display NoticeResponse messages, even when the connection is
    nominally idle.</p>

    <p>ParameterStatus messages will be generated whenever the
    active value changes for any of the parameters the backend
    believes the frontend should know about. Most commonly this
    occurs in response to a <tt class="COMMAND">SET</tt> SQL
    command executed by the frontend, and this case is effectively
    synchronous — but it is also possible for parameter status
    changes to occur because the administrator changed a
    configuration file and then sent the <span class="SYSTEMITEM">SIGHUP</span> signal to the server. Also, if a
    <tt class="COMMAND">SET</tt> command is rolled back, an
    appropriate ParameterStatus message will be generated to report
    the current effective value.</p>

    <p>At present there is a hard-wired set of parameters for which
    ParameterStatus will be generated: they are <tt class="VARNAME">server_version</tt>, <tt class="VARNAME">server_encoding</tt>, <tt class="VARNAME">client_encoding</tt>, <tt class="VARNAME">application_name</tt>, <tt class="VARNAME">is_superuser</tt>, <tt class="VARNAME">session_authorization</tt>, <tt class="VARNAME">DateStyle</tt>, <tt class="VARNAME">IntervalStyle</tt>, <tt class="VARNAME">TimeZone</tt>, <tt class="VARNAME">integer_datetimes</tt>, and <tt class="VARNAME">standard_conforming_strings</tt>. (<tt class="VARNAME">server_encoding</tt>, <tt class="VARNAME">TimeZone</tt>, and <tt class="VARNAME">integer_datetimes</tt> were not reported by releases
    before 8.0; <tt class="VARNAME">standard_conforming_strings</tt> was not reported by
    releases before 8.1; <tt class="VARNAME">IntervalStyle</tt> was
    not reported by releases before 8.4; <tt class="VARNAME">application_name</tt> was not reported by releases
    before 9.0.) Note that <tt class="VARNAME">server_version</tt>,
    <tt class="VARNAME">server_encoding</tt> and <tt class="VARNAME">integer_datetimes</tt> are pseudo-parameters that
    cannot change after startup. This set might change in the
    future, or even become configurable. Accordingly, a frontend
    should simply ignore ParameterStatus for parameters that it
    does not understand or care about.</p>

    <p>If a frontend issues a <tt class="COMMAND">LISTEN</tt>
    command, then the backend will send a NotificationResponse
    message (not to be confused with NoticeResponse!) whenever a
    <tt class="COMMAND">NOTIFY</tt> command is executed for the
    same channel name.</p>

    <div class="NOTE">
      <blockquote class="NOTE">
        <p><b>Note:</b> At present, NotificationResponse can only
        be sent outside a transaction, and thus it will not occur
        in the middle of a command-response series, though it might
        occur just before ReadyForQuery. It is unwise to design
        frontend logic that assumes that, however. Good practice is
        to be able to accept NotificationResponse at any point in
        the protocol.</p>
      </blockquote>
    </div>
  </div>

  <div class="SECT2">
    <h2 class="SECT2"><a name="AEN102827" id="AEN102827">49.2.7.
    Canceling Requests in Progress</a></h2>

    <p>During the processing of a query, the frontend might request
    cancellation of the query. The cancel request is not sent
    directly on the open connection to the backend for reasons of
    implementation efficiency: we don't want to have the backend
    constantly checking for new input from the frontend during
    query processing. Cancel requests should be relatively
    infrequent, so we make them slightly cumbersome in order to
    avoid a penalty in the normal case.</p>

    <p>To issue a cancel request, the frontend opens a new
    connection to the server and sends a CancelRequest message,
    rather than the StartupMessage message that would ordinarily be
    sent across a new connection. The server will process this
    request and then close the connection. For security reasons, no
    direct reply is made to the cancel request message.</p>

    <p>A CancelRequest message will be ignored unless it contains
    the same key data (PID and secret key) passed to the frontend
    during connection start-up. If the request matches the PID and
    secret key for a currently executing backend, the processing of
    the current query is aborted. (In the existing implementation,
    this is done by sending a special signal to the backend process
    that is processing the query.)</p>

    <p>The cancellation signal might or might not have any effect —
    for example, if it arrives after the backend has finished
    processing the query, then it will have no effect. If the
    cancellation is effective, it results in the current command
    being terminated early with an error message.</p>

    <p>The upshot of all this is that for reasons of both security
    and efficiency, the frontend has no direct way to tell whether
    a cancel request has succeeded. It must continue to wait for
    the backend to respond to the query. Issuing a cancel simply
    improves the odds that the current query will finish soon, and
    improves the odds that it will fail with an error message
    instead of succeeding.</p>

    <p>Since the cancel request is sent across a new connection to
    the server and not across the regular frontend/backend
    communication link, it is possible for the cancel request to be
    issued by any process, not just the frontend whose query is to
    be canceled. This might provide additional flexibility when
    building multiple-process applications. It also introduces a
    security risk, in that unauthorized persons might try to cancel
    queries. The security risk is addressed by requiring a
    dynamically generated secret key to be supplied in cancel
    requests.</p>
  </div>

  <div class="SECT2">
    <h2 class="SECT2"><a name="AEN102835" id="AEN102835">49.2.8.
    Termination</a></h2>

    <p>The normal, graceful termination procedure is that the
    frontend sends a Terminate message and immediately closes the
    connection. On receipt of this message, the backend closes the
    connection and terminates.</p>

    <p>In rare cases (such as an administrator-commanded database
    shutdown) the backend might disconnect without any frontend
    request to do so. In such cases the backend will attempt to
    send an error or notice message giving the reason for the
    disconnection before it closes the connection.</p>

    <p>Other termination scenarios arise from various failure
    cases, such as core dump at one end or the other, loss of the
    communications link, loss of message-boundary synchronization,
    etc. If either frontend or backend sees an unexpected closure
    of the connection, it should clean up and terminate. The
    frontend has the option of launching a new backend by
    recontacting the server if it doesn't want to terminate itself.
    Closing the connection is also advisable if an unrecognizable
    message type is received, since this probably indicates loss of
    message-boundary sync.</p>

    <p>For either normal or abnormal termination, any open
    transaction is rolled back, not committed. One should note
    however that if a frontend disconnects while a non-<tt class="COMMAND">SELECT</tt> query is being processed, the backend
    will probably finish the query before noticing the
    disconnection. If the query is outside any transaction block
    (<tt class="COMMAND">BEGIN</tt> ... <tt class="COMMAND">COMMIT</tt> sequence) then its results might be
    committed before the disconnection is recognized.</p>
  </div>

  <div class="SECT2">
    <h2 class="SECT2"><a name="AEN102844" id="AEN102844">49.2.9.
    <acronym class="ACRONYM">SSL</acronym> Session
    Encryption</a></h2>

    <p>If <span class="PRODUCTNAME">PostgreSQL</span> was built
    with <acronym class="ACRONYM">SSL</acronym> support,
    frontend/backend communications can be encrypted using
    <acronym class="ACRONYM">SSL</acronym>. This provides
    communication security in environments where attackers might be
    able to capture the session traffic. For more information on
    encrypting <span class="PRODUCTNAME">PostgreSQL</span> sessions
    with <acronym class="ACRONYM">SSL</acronym>, see <a href="http://www.postgresql.org/docs/devel/static/ssl-tcp.html">Section 17.9</a>.</p>

    <p>To initiate an <acronym class="ACRONYM">SSL</acronym>-encrypted connection, the frontend
    initially sends an SSLRequest message rather than a
    StartupMessage. The server then responds with a single byte
    containing <tt class="LITERAL">S</tt> or <tt class="LITERAL">N</tt>, indicating that it is willing or unwilling to
    perform <acronym class="ACRONYM">SSL</acronym>, respectively.
    The frontend might close the connection at this point if it is
    dissatisfied with the response. To continue after <tt class="LITERAL">S</tt>, perform an <acronym class="ACRONYM">SSL</acronym> startup handshake (not described here,
    part of the <acronym class="ACRONYM">SSL</acronym>
    specification) with the server. If this is successful, continue
    with sending the usual StartupMessage. In this case the
    StartupMessage and all subsequent data will be <acronym class="ACRONYM">SSL</acronym>-encrypted. To continue after <tt class="LITERAL">N</tt>, send the usual StartupMessage and proceed
    without encryption.</p>

    <p>The frontend should also be prepared to handle an
    ErrorMessage response to SSLRequest from the server. This would
    only occur if the server predates the addition of
    <acronym class="ACRONYM">SSL</acronym> support to <span class="PRODUCTNAME">PostgreSQL</span>. (Such servers are now very
    ancient, and likely do not exist in the wild anymore.) In this
    case the connection must be closed, but the frontend might
    choose to open a fresh connection and proceed without
    requesting <acronym class="ACRONYM">SSL</acronym>.</p>

    <p>An initial SSLRequest can also be used in a connection that
    is being opened to send a CancelRequest message.</p>

    <p>While the protocol itself does not provide a way for the
    server to force <acronym class="ACRONYM">SSL</acronym>
    encryption, the administrator can configure the server to
    reject unencrypted sessions as a byproduct of authentication
    checking.</p>
  </div>
</div>

<div class="NAVFOOTER">
  <hr class="c1" width="100%">

  <table summary="Footer navigation table" cellpadding="0" cellspacing="0" border="0" width="100%">
    <tbody><tr>
      <td align="left" valign="top" width="33%"><a href="http://www.postgresql.org/docs/devel/static/protocol-overview.html" accesskey="P">Prev</a></td>

      <td align="center" valign="top" width="34%"><a href="http://www.postgresql.org/docs/devel/static/index.html" accesskey="H">Home</a></td>

      <td align="right" valign="top" width="33%"><a href="http://www.postgresql.org/docs/devel/static/protocol-replication.html" accesskey="N">Next</a></td>
    </tr>

    <tr>
      <td align="left" valign="top" width="33%">Overview</td>

      <td align="center" valign="top" width="34%"><a href="http://www.postgresql.org/docs/devel/static/protocol.html" accesskey="U">Up</a></td>

      <td align="right" valign="top" width="33%">Streaming
      Replication Protocol</td>
    </tr>
  </tbody></table>
</div>

</div>

<div id="docComments">



</div>

<div id="docFooter">
    <a href="http://www.postgresql.org/about/privacypolicy">Privacy Policy</a> |
    <a href="http://www.postgresql.org/about/">About PostgreSQL</a><br>
Copyright © 1996-2014 The PostgreSQL Global Development Group
</div>
</div>
</div>


</body></html>